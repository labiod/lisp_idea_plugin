{
    parserClass="com.kgb.lisp.parser.LispParser"
//    parserUtilClass="com.kgb.lisp.parser.LispParserUtil"

    psiClassPrefix="Lisp"
    psiImplClassSuffix="Impl"
    psiPackage="com.kgb.lisp.psi"
    psiImplPackage="com.kgb.lisp.psi.impl"
    psiImplUtilClass="com.kgb.lisp.psi.impl.LispPsiImplUtil"

    elementTypeHolderClass="com.kgb.lisp.psi.LispTypes"
    elementTypeClass="com.kgb.lisp.psi.LispElementType"
    tokenTypeClass="com.kgb.lisp.psi.LispElementType"

    tokens=[
        EQ='='
        LP='('
        RP=')'


        space='regexp:[\s\t]+'
        comment='regexp:;.*'
        number='regexp:\d+(\.\d*)?'
        string="regexp:(\"([^\"\\]|\\.)*\")"
        TRUE="true"
        FALSE="false"
        IF_NULL="null"
        NULL="nil"

        op_1='+'
        op_2='-'
        op_3='*'
        op_4='/'
        op_5='!'
        op_6='>'
        op_7='<'

        //keywords block
        QV="'"
        LOOP="loop"
        FOR="for"
        IN="in"
        FROM="from"
        DOWNFROM="downfrom"
        TO="to"
        UPTO="upto"
        DOWNTO="downto"
        DO="do"
        COLLECT="collect"
        DEFUN="defun"
        LET="let"
        IF="if"
        car="car"
        cdr="cdr"
        setq="setq"
        cons="cons"
        //keywords block end
        PF_NAME="regexp:[a-zA-Z][a-zA-Z_\-0-9]*"
      ]
}


root ::= root_item *

//root_item definition

private root_item ::= !<<eof>> block_body

block_body ::= def_fun | special_form | call_func | empty_block | if_form | def_structure

//**************************************************************************
//base structure and function definition

basic_type ::= number | string | boolean_value | NULL | string_value | list

string_value ::= QV string_arg

string_arg ::= var | boolean_value | number | PF_NAME

boolean_value ::= TRUE | FALSE

list ::= QV LP SPACE* string_arg* SPACE* RP

keywords ::= LOOP | FOR | IN | FROM | TO | DO | COLLECT | DEFUN | LET | IF | setq

base_function ::= write | print | operation | car | cdr | cons

operation ::=  OP_1 | OP_2 | OP_3 | OP_4 | OP_5 | OP_6 | OP_7

var ::= PF_NAME

func_name ::= PF_NAME | base_function

//define new function
def_fun ::= LP SPACE* DEFUN SPACE* func_name SPACE* LP SPACE* def_var* SPACE* RP SPACE* documentation? SPACE* function_body SPACE* RP {methods=[getFunctionName getArgumentCount]}

documentation ::= string

def_var ::= PF_NAME

empty_block ::= LP SPACE* RP

function_body ::= LP SPACE* block_body* SPACE* RP | block_body

arg ::= var | string_value | call_func | basic_type

special_form ::= loop_block | setq_block | let_block | base_function_form

base_function_form ::= LP SPACE* base_function SPACE* arg* SPACE* RP

def_struct ::= LP SPACE* DEFSTRUCT SPACE* struct_definition SPACE* struct_field_def* SPACE* RP

struct_definition ::= struct_name | (LP SPACE* struct_name SPACE* struct_option* SPACE* RP )

struct_name ::= PF_NAME

struct_option ::= (":conc-name" SPACE* struct_conc_name)

struct_conc_name ::= PF_NAME

struct_field_def ::= field_name | (LP SPACE* field_name SPACE* field_option* SPACE* RP)

field_name ::= PF_NAME

field_option ::= ":type " SPACE* field_type

field_type ::= "short-float"

//loop definition

loop_block ::= LP SPACE* LOOP SPACE* loop_for_block* SPACE* do_block? SPACE* RP

loop_for_block ::= FOR var SPACE* (loop_for_in_block | loop_for_from_block)

loop_for_in_block ::= IN SPACE* arg

loop_for_from_block ::= (FROM SPACE* number SPACE* TO SPACE* number) |
                        (DOWNFROM SPACE* number SPACE* TO SPACE* number) |
                        (FROM SPACE* number SPACE* DOWNTO number) |
                        (UPTO SPACE* number)

do_block ::= DO ((LP SPACE* block_body SPACE* RP ) | block_body )

//setq definition

setq_block ::= LP SPACE* SETQ SPACE* setq_args* SPACE* RP {methods=[getProperties]}

setq_args ::= (LP SPACE* var SPACE* arg SPACE* RP) | var SPACE* arg

//let definition

let_block ::= (LP SPACE* LET SPACE* LP SPACE* let_var_block* SPACE* RP SPACE* let_body* SPACE* RP)

let_var_block ::= LP SPACE* var SPACE* arg SPACE* RP

let_body ::= LP SPACE* block_body* SPACE* RP | block_body

//if form definition

if_form ::= LP SPACE* IF SPACE* conditions* SPACE* if_body SPACE* RP

if_body ::= (if_block? SPACE* else_block) | (if_block SPACE* else_block?) | (if_block SPACE* else_block)

conditions ::= (LP SPACE* IF_NULL SPACE* var SPACE* RP) | operation_form | var

if_block ::= LP SPACE* block_body* SPACE* RP | block_body | arg

else_block ::= (LP SPACE* block_body* SPACE* RP) | block_body | arg

//operation definition
operation_form ::= LP SPACE* operation SPACE* arg SPACE* arg SPACE* RP


//***************************************************************************

//Call function definition
call_func ::= LP SPACE* func_name SPACE* arg* SPACE* RP {pin=3 methods=wrong_call}

private wrong_call ::= !RP












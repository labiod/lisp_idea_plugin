{
    parserClass="com.kgb.lisp.parser.LispParser"
//    parserUtilClass="com.kgb.lisp.parser.LispParserUtil"

    psiClassPrefix="Lisp"
    psiImplClassSuffix="Impl"
    psiPackage="com.kgb.lisp.psi"
    psiImplPackage="com.kgb.lisp.psi.impl"
    psiImplUtilClass="com.kgb.lisp.psi.impl.LispPsiImplUtil"

    elementTypeHolderClass="com.kgb.lisp.psi.LispTypes"
    elementTypeClass="com.kgb.lisp.psi.LispElementType"
    tokenTypeClass="com.kgb.lisp.psi.LispElementType"

    tokens=[
        SEMI=';'
        EQ='='
        LP='('
        RP=')'

        space='regexp:[\s\t]+'
        comment='regexp://.*'
        number='regexp:\d+(\.\d*)?'
        string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

        op_1='+'
        op_2='-'
        op_3='*'
        op_4='/'
        op_5='!'
        PF_NAME="regexp:[a-zA-Z][a-zA-Z_\-0-9]*"
        KEYWORD="regexp:(do)|(loop)|(in)|(for)"
        DEFUN="defun"
        LET="let"
        IF_NULL="null"
        NULL="nil"
        IF="if"
      ]
}

root ::= root_item *

private root_item ::= !<<eof>> block_body

private block_body ::= let_def | def_fun_item | call_func | if_statement | empty_block

empty_block ::= LP SPACE* RP

def_fun_item ::= LP SPACE * DEFUN SPACE* PF_NAME SPACE* LP SPACE* def_func_args* SPACE* RP SPACE* block_body SPACE* RP

call_func ::= LP SPACE* func_name SPACE* call_func_args* SPACE* RP

let_def ::= LP SPACE* LET SPACE* LP SPACE* property_def* SPACE* RP SPACE* block_body SPACE* RP

if_statement ::= LP SPACE* IF SPACE* if_condition SPACE* if_block SPACE* else_block SPACE* RP

func_name ::= PF_NAME

def_func_args ::= ('regexp:[a-zA-Z][a-zA-Z_\-0-9]*')

private property_def ::= LP SPACE* PF_NAME SPACE* property_value SPACE* RP

private property_value ::= (number)|(string)

private call_func_args ::= empty_block | PF_NAME | call_func

private if_condition ::= (LP SPACE* IF_NULL SPACE* PF_NAME SPACE* RP)

private if_block ::= block_body | NULL | PF_NAME | (LP SPACE* (NULL|PF_NAME) SPACE* RP)

private else_block ::= if_block





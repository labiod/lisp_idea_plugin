{
    parserClass="com.kgb.lisp.parser.LispParser"
//    parserUtilClass="com.kgb.lisp.parser.LispParserUtil"

    psiClassPrefix="Lisp"
    psiImplClassSuffix="Impl"
    psiPackage="com.kgb.lisp.psi"
    psiImplPackage="com.kgb.lisp.psi.impl"
    psiImplUtilClass="com.kgb.lisp.psi.impl.LispPsiImplUtil"

    elementTypeHolderClass="com.kgb.lisp.psi.LispTypes"
    elementTypeClass="com.kgb.lisp.psi.LispElementType"
    tokenTypeClass="com.kgb.lisp.psi.LispElementType"

    tokens=[
        EQ='='
        LP='('
        RP=')'


        space='regexp:[\s\t]+'
        comment='regexp:;.*'
        number='regexp:\d+(\.\d*)?'
        string="regexp:(\"([^\"\\]|\\.)*\")"
        TRUE="true"
        FALSE="false"

        op_1='+'
        op_2='-'
        op_3='*'
        op_4='/'
        op_5='!'
        op_6='>'
        op_7='<'

        //keywords block
        QV="'"
        KEYWORD="regexp:(car)|(cdr)"
        LOOP="loop"
        FOR="for"
        IN="in"
        FROM="from"
        TO="to"
        DO="do"
        COLLECT="collect"
        DEFUN="defun"
        LET="let"
        IF_NULL="null"
        NULL="nil"
        IF="if"
        car="car"
        cdr="cdr"
        setq="setq"
        cons="cons"
        //keywords block end
        PF_NAME="regexp:[a-zA-Z][a-zA-Z_\-0-9]*"
      ]
}

root ::= root_item *

private root_item ::= !<<eof>> block_body

private block_body ::= let_def | def_fun_item | call_func | if_statement | empty_block | loop_block

empty_block ::= LP SPACE* RP

def_fun_item ::= LP SPACE* DEFUN SPACE* func_name SPACE* LP SPACE* var_def* SPACE* RP SPACE* block_body+ SPACE* RP {methods=[getFunctionName]}

call_func ::= LP SPACE* func_name SPACE* func_arg* SPACE* RP

let_def ::= LP SPACE* LET SPACE* LP SPACE* property_def* SPACE* RP SPACE* block_body SPACE* RP

if_statement ::= LP SPACE* IF SPACE* if_condition+ SPACE* if_block? SPACE* else_block? SPACE* RP

func_name ::= PF_NAME | CAR | CDR | SETQ | CONS

loop_block ::= LP SPACE* LOOP SPACE* FOR SPACE* var_def SPACE* from_in_block+ SPACE* SPACE* do_block* SPACE* collect_block* SPACE* RP

operation_call ::= LP SPACE* operation_type SPACE* op_value SPACE* op_value SPACE* RP

to_string ::= QV (TRUE | FALSE | number | PF_NAME)

setq_block ::= LP SPACE* setq SPACE* setq_items+ SPACE* RP {methods=[getProperty]}

setq_items ::= (LP SPACE* var_def SPACE* var_value SPACE* )

var_def ::= PF_NAME

var_value ::= var_def | call_func | number | string | NULL | TRUE | FALSE | to_string | list

func_arg ::= var | call_func | list | to_string | operation_call | number | string | NULL

var ::= PF_NAME

private operation_type ::= OP_1 | OP_2 | OP_3 | OP_4 | OP_5 | OP_6 | OP_7

private op_value ::= var | NULL | number | string | call_func | to_string

private list ::= var | (QV LP SPACE* list_item* SPACE* RP)

private from_in_block ::= (IN SPACE* list) | (FROM SPACE* list_item SPACE* TO SPACE* number)

private do_block ::= DO block_body

private list_item ::= number | string | var | NULL | to_string

private collect_block ::= COLLECT SPACE* PF_NAME

private property_def ::= LP SPACE* var_def SPACE* property_value SPACE* RP

private property_value ::= (number)|(string)


private if_condition ::= (LP SPACE* if_value+ SPACE* RP) | if_value

private if_value ::= IF_NULL | operation_call | number | string | PF_NAME | NULL

private if_block ::= block_body | NULL | var | (LP SPACE* (NULL|PF_NAME) SPACE* RP)

private else_block ::= if_block




